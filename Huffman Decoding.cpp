/*You are given an encoded binary string and a Huffman MinHeap tree, your task is to complete the function decodeHuffmanData(), which decodes the binary encoded string and returns the original string. 
Note: Each node of the min heap contains 2 data members, a character, and an integer to denoting its frequency. The character '$' is the special character used for internal nodes whose min heap node only needs an integer field. The code in the chart is generated by the following rule:
- If we want to reach a node from the root then in the path, for right turn we use 1 and for left turn we use 0.

*/

#include <iostream>
#include <string>
using namespace std;

// Structure of the node of Huffman tree
struct MinHeapNode {
    char data;
    int freq;
    MinHeapNode *left, *right;

    MinHeapNode(char d, int f) {
        data = d;
        freq = f;
        left = right = NULL;
    }
};

class Solution {
  public:
    string decodeHuffmanData(MinHeapNode* root, string binaryString) {
        string decoded = "";
        MinHeapNode* curr = root;

        for (char bit : binaryString) {
            if (bit == '0') {
                curr = curr->left;
            } else {
                curr = curr->right;
            }

            // If we reach a leaf node
            if (!curr->left && !curr->right) {
                decoded += curr->data;
                curr = root;  // reset to root for next character
            }
        }

        return decoded;
    }
};

// Helper function to build a sample Huffman tree manually for testing
MinHeapNode* buildSampleTree1() {
    // Based on the first example in the prompt
    MinHeapNode* root = new MinHeapNode('$', 20);
    root->left = new MinHeapNode('$', 8);
    root->right = new MinHeapNode('$', 12);

    root->left->left = new MinHeapNode('$', 3);
    root->left->right = new MinHeapNode('E', 5);

    root->left->left->left = new MinHeapNode('B', 1);
    root->left->left->right = new MinHeapNode('D', 2);

    root->right->left = new MinHeapNode('C', 6);
    root->right->right = new MinHeapNode('A', 6);

    return root;
}

MinHeapNode* buildSampleTree2() {
    // Based on the second example in the prompt
    MinHeapNode* root = new MinHeapNode('$', 13);
    root->left = new MinHeapNode('$', 5);
    root->right = new MinHeapNode('$', 8);

    root->left->left = new MinHeapNode('$', 3);
    root->left->right = new MinHeapNode('g', 2);

    root->left->left->left = new MinHeapNode('$', 2);
    root->left->left->right = new MinHeapNode('r', 1);

    root->left->left->left->left = new MinHeapNode('f', 1);
    root->left->left->left->right = new MinHeapNode('o', 1);

    root->right->left = new MinHeapNode('$', 4);
    root->right->right = new MinHeapNode('e', 4);

    root->right->left->left = new MinHeapNode('k', 2);
    root->right->left->right = new MinHeapNode('s', 2);

    return root;
}

int main() {
    Solution sol;

    // Test Case 1
    string encoded1 = "1111111111110001010101010100010010101010101";
    MinHeapNode* tree1 = buildSampleTree1();
    string result1 = sol.decodeHuffmanData(tree1, encoded1);
    cout << "Decoded String 1: " << result1 << endl; // Output: AAAAAABCCCCCCDDEEEEE

    // Test Case 2
    string encoded2 = "01110100011111000101101011101000111";
    MinHeapNode* tree2 = buildSampleTree2();
    string result2 = sol.decodeHuffmanData(tree2, encoded2);
    cout << "Decoded String 2: " << result2 << endl; // Output: geeksforgeeks

    return 0;
}
